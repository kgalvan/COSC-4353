package mastermind;

import java.awt.*;
import java.util.*;
import java.util.List;
        
//Venkat: 
//import java.util.stream.IntStream;
//import java.util.function.IntFunction;
//import java.util.function.Function;
//import static java.util.stream.Collectors.groupingBy;
//import static java.util.stream.Collectors.counting;

import static mastermind.MasterMind.Response.*;

public class MasterMind {
    enum Response{ NO_MATCH, MATCH, POSITIONAL_MATCH }

    //private final int SIZE = 6; //Venkat: we may use this instaed of hardcoding 6
    
    private List<Color> solution;

    public MasterMind(List<Color> selection) {
        solution = selection;
    }//Venkat: one blank line between methods, please
    public Map<Response,Integer> guess(List<Color> userGuess) {
        List<Color> returnList = new ArrayList<Color>();
        int blackCounter = 0;
        int silverCounter = 0;
        int nomatch = 6;
        Map<Response,Integer> responseIntegerMap = new HashMap<>();
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 6; j++) {
                if(solution.get(i) == userGuess.get(j)){
                    if(i == j){
                        blackCounter = blackCounter + 1;
        
                    }
                    else{
                        silverCounter = silverCounter + 1;
        
                    }
                    break;
                }
            }
        }
        if (blackCounter == 0 && silverCounter == 0) {
            returnList = null;
        }
        
        for(int i = 0; i < blackCounter; i++) {
            returnList.add(Color.BLACK);
        }
        for(int i = 0; i < silverCounter; i++) {
            returnList.add(Color.GRAY);
        }
        nomatch -= (blackCounter+silverCounter);
        
        responseIntegerMap.put(NO_MATCH,nomatch);
        responseIntegerMap.put(MATCH,silverCounter);
        responseIntegerMap.put(POSITIONAL_MATCH,blackCounter);
        return responseIntegerMap;
        
        //Venkat: How about instead of all the above code we write the following:


        //IntFunction<Response> computeMatchAtPosition = index -> 
        //  solution.get(index) == userGuess.get(index) ? POSITIONAL_MATCH :
        //    userGuess.contains(solution.get(index)) ? MATCH : NO_MATCH;
        //
        //Map<Response, Long> response = 
        //  IntStream.range(0, SIZE)
        //    .mapToObj(computeMatchAtPosition)
        //    .collect(groupingBy(Function.identity(), counting()));
        //
        //response.computeIfAbsent(NO_MATCH, key -> 0L);
        //response.computeIfAbsent(MATCH, key -> 0L);
        //response.computeIfAbsent(POSITIONAL_MATCH, key -> 0L);
        //
        //return response;
    }

}
